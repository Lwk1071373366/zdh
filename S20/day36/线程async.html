<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="referrer" content="origin" />
    <title>python之路——线程 - Eva_J - 博客园</title>
<meta property="og:description" content="简介 操作系统线程理论 线程概念的引入背景 线程的特点 进程和线程的关系 使用线程的实际场景 用户级线程和内核级线程(了解) 线程和python 理论知识 线程的创建Threading.Thread类" />
    <link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=svlZeZMvc3He7PqOD4T7SOuQn0_kIfLBYiy3idqd35Y1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/LoveIsIntheAir/bundle-LoveIsIntheAir.css?v=1a1njKMb9NXq0SiMQC1DxNR7neAOH_-_T7CqiC-KPw41"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/250832.css?v=sgnWqV5WAgR4lMmYSWvpJe19YwI%3d"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/LoveIsIntheAir/bundle-LoveIsIntheAir-mobile.css?v=2vKssTQro2c1xn1VJpQlerpUCrPsZu0FDfkhm7xMpkY1"/>
    <link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/Eva-J/rss"/>
    <link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/Eva-J/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/Eva-J/wlwmanifest.xml"/>
    <script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script>var currentBlogId=250832;var currentBlogApp='Eva-J',cb_enable_mathjax=false;var isLogined=false;</script>
    <script src="/bundles/blog-common.js?v=OFBZTzkHKauV7mtIFLF9jlqrX-sesK9-mY9KjurLrq01" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<!--PageBeginHtml Block Begin-->
<h2 style="line-height: 1.5em; float: left; text-align: right; color: #816d65; position: absolute; top: 110px; left: 110px; background: #d2eef4">程序媛</h2>
<!--PageBeginHtml Block End-->

<!--done-->
<center>
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/Eva-J/"><img id="blogLogo" src="/Skins/LoveIsIntheAir/images/logo.gif" alt="" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/Eva-J/">Eva_J</a></h1>
<h2></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
	<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
	<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/Eva-J/">首页</a></li>
	<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
	<li><a id="blog_nav_contact" accesskey="9" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/Eva_J">联系</a></li>
	<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
	<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/Eva-J/rss">订阅</a>
	<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/Eva-J/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<!--done-->
随笔- 32&nbsp;
文章- 124&nbsp;
评论- 268&nbsp;
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div class="clear"></div>
	<div id="topicList">
		
        <div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/Eva-J/articles/8306047.html">python之路——线程</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><h1>简介</h1>
<div id="cnblogs_post_body"><a name="_labelTop"></a>
<ul>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label1">操作系统线程理论</a>
<ul>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label2">线程概念的引入背景</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label3">线程的特点</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label4">进程和线程的关系</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label5">使用线程的实际场景</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label7">用户级线程和内核级线程(了解)</a></li>
</ul>
</li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label8">线程和python</a>
<ul>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label9">理论知识</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label10">线程的创建Threading.Thread类</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label11">锁</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label16">队列</a></li>
<li><a style="color: darkseagreen; text-decoration: none; font-size: 18px;" href="#_label17">Python标准模块--concurrent.futures</a></li>
</ul>
</li>
</ul>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label1"></a></div>
<h1>操作系统线程理论</h1>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label2"></a></div>
<h2>线程概念的引入背景</h2>
<h3>进程</h3>
<div class="para">
<p>　　之前我们已经了解了操作系统中进程的概念，程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p>
<h3>有了进程为什么要有线程</h3>
<p>　　进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p>
<ul>
<li>
<p>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</p>
</li>
<li>
<p>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</p>
</li>
</ul>
<p>　　如果这两个缺点理解比较困难的话，举个现实的例子也许你就清楚了：如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二。</p>
<p>　　现在你应该明白了进程的缺陷了，而解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。而实际的操作系统中，也同样引入了这种类似的机制&mdash;&mdash;线程。</p>
<h3>线程的出现</h3>
</div>
<div class="para">　　60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入<strong>轻型进程</strong>；二是由于对称多处理机（SMP）出现，<strong>可以满足多个运行单位</strong>，而多个进程并行开销过大。</div>
<div class="para">　　因此在80年代，出现了<strong>能独立运行的基本单位</strong>&mdash;&mdash;线程（Threads）<strong>。</strong></div>
<div class="para"><strong>　　注意：进程是资源分配的最小单位,线程是CPU调度的最小单位.</strong></div>
<div class="para"><strong>　　　　　每一个进程中至少有一个线程。　</strong></div>
<div class="para">
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label4"></a></div>
<h2 class="para"><strong>进程和线程的关系</strong></h2>
<p><strong>　　<img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180118212223115-85632065.png" alt="" width="289" height="196" /></strong></p>
<div class="para"><strong>　　线程与进程的区别</strong>可以归纳为以下4点：</div>
<div class="para">　　1）地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</div>
<div class="para">　　2）通信：<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank">进程间通信</a><a href="https://baike.baidu.com/item/IPC" target="_blank">IPC</a>，线程间可以直接读写进程数据段（如全局变量）来进行通信&mdash;&mdash;需要<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5" target="_blank">进程同步</a>和互斥手段的辅助，以保证数据的一致性。</div>
<div class="para">　　3）调度和切换：线程上下文切换比进程上下文切换要快得多。</div>
<div class="para">　　4）在多线程操作系统中，进程不是一个可执行的实体。</div>
<div class="para">　　<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank">*通过漫画了解线程进城</a></div>
</div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label3"></a></div>
<h2 class="para"><strong>线程的特点</strong></h2>
<div class="para">
<div class="para">　　在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</div>
<div class="para">　　1）轻型实体</div>
<div class="para">　　线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。</div>
<div class="para">　　线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。</div>
<div class="para">
<div class="cnblogs_code" onclick="cnblogs_code_show('9dadf0b0-cd65-47f8-8d93-61e356da4b06')"><img id="code_img_closed_9dadf0b0-cd65-47f8-8d93-61e356da4b06" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9dadf0b0-cd65-47f8-8d93-61e356da4b06" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9dadf0b0-cd65-47f8-8d93-61e356da4b06',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9dadf0b0-cd65-47f8-8d93-61e356da4b06" class="cnblogs_code_hide">
<pre><span style="color: #000000;">TCB包括以下信息：
（</span>1<span style="color: #000000;">）线程状态。
（</span>2<span style="color: #000000;">）当线程不运行时，被保存的现场资源。
（</span>3<span style="color: #000000;">）一组执行堆栈。
（</span>4<span style="color: #000000;">）存放每个线程的局部变量主存区。
（</span>5<span style="color: #000000;">）访问同一个进程中的主存和其它资源。
用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</span></pre>
</div>
<span class="cnblogs_code_collapse">TCB包括以下信息</span></div>
</div>
<div class="para">　　2）独立调度和分派的基本单位。</div>
<div class="para">　　在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很&ldquo;轻&rdquo;，故线程的切换非常迅速且开销小（在同一进程中的）。</div>
<div class="para">　　3）共享进程资源。
<div class="lemma-picture text-pic layout-right"><span class="description">　　线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</span></div>
</div>
<div class="para">　　4<em>）可并发执行。</em></div>
<div class="para"><em>　　在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</em></div>
<div class="para">　　</div>
</div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label5"></a></div>
<h2 class="para">使用线程的实际场景</h2>
<p><img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180118213009115-1272261459.png" alt="" /></p>
<p>&nbsp;</p>
<p>　　开启一个字处理软件进程，该进程肯定需要办不止一件事情，比如监听键盘输入，处理文字，定时自动将文字保存到硬盘，这三个任务操作的都是同一块数据，因而不能用多进程。只能在一个进程里并发地开启三个线程,如果是单线程，那就只能是，键盘输入时，不能处理文字和自动保存，自动保存时又不能输入和处理文字。</p>
<h2>内存中的线程</h2>
<p><img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180118213709271-527249129.png" alt="" width="637" height="274" /></p>
<p>&nbsp;</p>
<p>　　多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程。</p>
<p>　　而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。</p>
<p>　　不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。</p>
<p>　　类似于进程，每个线程也有自己的堆栈，不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。</p>
<p>　　线程通常是有益的，但是带来了不小程序设计难度，线程的问题是：</p>
<p>　　1. 父进程有多个线程，那么开启的子线程是否需要同样多的线程</p>
<p>　　2. 在同一个进程中，如果一个线程关闭了文件，而另外一个线程正准备往该文件内写内容呢？</p>
<p>　　因此，在多线程的代码中，需要更多的心思来设计程序的逻辑、保护程序的数据。</p>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label6"></a></div>
<h2>用户级线程和内核级线程（了解）</h2>
<p>　　线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。&nbsp;</p>
<h3>用户级线程</h3>
<p>　　内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180121020547006-752791661.png" alt="" /></p>
<p>　　在用户空间模拟操作系统对进程的调度，来调用一个进程中的线程，每个进程中都会有一个运行时系统，用来调度线程。此时当该进程获取cpu时，进程内再调度出一个线程去执行，同一时刻只有一个线程执行。</p>
<h3>内核级线程</h3>
<p>　　&nbsp;内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的。</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180121020859803-1526586154.png" alt="" /></p>
<div class="para">
<h3>用户级与内核级线程的对比</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('810b3da2-6b29-499c-b30b-e7e2b25e8104')"><img id="code_img_closed_810b3da2-6b29-499c-b30b-e7e2b25e8104" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_810b3da2-6b29-499c-b30b-e7e2b25e8104" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('810b3da2-6b29-499c-b30b-e7e2b25e8104',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_810b3da2-6b29-499c-b30b-e7e2b25e8104" class="cnblogs_code_hide">
<pre><span style="color: #008080;">1</span> <span style="color: #000000;">内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。
</span><span style="color: #008080;">2</span> <span style="color: #000000;">用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。
</span><span style="color: #008080;">3</span> <span style="color: #000000;">用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。
</span><span style="color: #008080;">4</span> <span style="color: #000000;">在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。
</span><span style="color: #008080;">5</span> 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</pre>
</div>
<span class="cnblogs_code_collapse">用户级线程和内核级线程的区别</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('641fd15e-7aff-49eb-a0bb-117a36017558')"><img id="code_img_closed_641fd15e-7aff-49eb-a0bb-117a36017558" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_641fd15e-7aff-49eb-a0bb-117a36017558" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('641fd15e-7aff-49eb-a0bb-117a36017558',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_641fd15e-7aff-49eb-a0bb-117a36017558" class="cnblogs_code_hide">
<pre><span style="color: #000000;">优点：当有多个处理机时，一个进程的多个线程可以同时执行。
缺点：由内核进行调度。</span></pre>
</div>
<span class="cnblogs_code_collapse">内核线程的优缺点</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('d1f77720-7e34-4579-959f-f917917e1618')"><img id="code_img_closed_d1f77720-7e34-4579-959f-f917917e1618" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d1f77720-7e34-4579-959f-f917917e1618" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d1f77720-7e34-4579-959f-f917917e1618',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d1f77720-7e34-4579-959f-f917917e1618" class="cnblogs_code_hide">
<pre><span style="color: #000000;">优点：
线程的调度不需要内核直接参与，控制简单。
可以在不支持线程的操作系统中实现。
创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。
允许每个进程定制自己的调度算法，线程管理比较灵活。
线程能够利用的表空间和堆栈空间比内核级线程多。
同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。
缺点：
资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</span></pre>
</div>
<span class="cnblogs_code_collapse">用户级线程的优缺点</span></div>
<h3>混合实现</h3>
</div>
<p>　　用户级与内核级的多路复用，内核同一调度内核线程，每个内核线程对应n个用户线程</p>
<p>　　<img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180121021033553-698190505.png" alt="" /></p>
<h4>　　linux操作系统的 NPTL　　　　</h4>
<div class="cnblogs_code" onclick="cnblogs_code_show('e065bc98-3b66-4ef6-937e-d5de371fc0b6')"><img id="code_img_closed_e065bc98-3b66-4ef6-937e-d5de371fc0b6" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e065bc98-3b66-4ef6-937e-d5de371fc0b6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e065bc98-3b66-4ef6-937e-d5de371fc0b6',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e065bc98-3b66-4ef6-937e-d5de371fc0b6" class="cnblogs_code_hide">
<pre><span style="color: #000000;">历史
在内核2.6以前的调度实体都是进程，内核并没有真正支持线程。它是能过一个系统调用clone()来实现的，这个调用创建了一份调用进程的拷贝，跟fork()不同的是,这份进程拷贝完全共享了调用进程的地址空间。LinuxThread就是通过这个系统调用来提供线程在内核级的支持的(许多以前的线程实现都完全是在用户态，内核根本不知道线程的存在)。非常不幸的是，这种方法有相当多的地方没有遵循POSIX标准，特别是在信号处理，调度，进程间通信原语等方面。

很显然，为了改进LinuxThread必须得到内核的支持，并且需要重写线程库。为了实现这个需求，开始有两个相互竞争的项目：IBM启动的NGTP(Next Generation POSIX Threads)项目，以及Redhat公司的NPTL。在2003年的年中，IBM放弃了NGTP，也就是大约那时，Redhat发布了最初的NPTL。

NPTL最开始在redhat linux 9里发布，现在从RHEL3起内核2.6起都支持NPTL，并且完全成了GNU C库的一部分。

 

设计
NPTL使用了跟LinuxThread相同的办法，在内核里面线程仍然被当作是一个进程，并且仍然使用了clone()系统调用(在NPTL库里调用)。但是，NPTL需要内核级的特殊支持来实现，比如需要挂起然后再唤醒线程的线程同步原语futex.

NPTL也是一个1</span>*<span style="color: #000000;">1的线程库，就是说，当你使用pthread_create()调用创建一个线程后，在内核里就相应创建了一个调度实体，在linux里就是一个新进程，这个方法最大可能的简化了线程的实现。

除NPTL的1</span>*1模型外还有一个m*n模型，通常这种模型的用户线程数会比内核的调度实体多。在这种实现里，线程库本身必须去处理可能存在的调度，这样在线程库内部的上下文切换通常都会相当的快，因为它避免了系统调用转到内核态。然而这种模型增加了线程实现的复杂性,并可能出现诸如优先级反转的问题，此外，用户态的调度如何跟内核态的调度进行协调也是很难让人满意。</pre>
</div>
<span class="cnblogs_code_collapse">介绍</span></div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label8"></a></div>
<h1>线程和python</h1>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label9"></a></div>
<h2>理论知识</h2>
<h3>全局解释器锁GIL</h3>
<p>　　Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行。虽然 Python 解释器中可以&ldquo;运行&rdquo;多个线程，但在任意时刻只有一个线程在解释器中运行。<br />　　对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p>
<p>　　在多线程环境中，Python 虚拟机按以下方式执行：</p>
<p>　　a、设置 GIL；</p>
<p>　　b、切换到一个线程去运行；</p>
<p>　　c、运行指定数量的字节码指令或者线程主动让出控制(可以调用 time.sleep(0))；</p>
<p>　　d、把线程设置为睡眠状态；</p>
<p>　　e、解锁 GIL；</p>
<p>　　d、再次重复以上所有步骤。<br />　　在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，直到这个函数结束为止(由于在这期间没有Python的字节码被运行，所以不会做线程切换)编写扩展的程序员可以主动解锁GIL。</p>
<h3>python线程模块的选择</h3>
<p>　　Python提供了几个用于多线程编程的模块，包括thread、threading和Queue等。thread和threading模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，threading提供了更高级别、功能更强的线程管理的功能。Queue模块允许用户创建一个可以用于多个线程之间共享数据的队列数据结构。<br />　　避免使用thread模块，因为更高级别的threading模块更为先进，对线程的支持更为完善，而且使用thread模块里的属性有可能会与threading出现冲突；其次低级别的thread模块的同步原语很少(实际上只有一个)，而threading模块则有很多；再者，thread模块中当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作，至少threading模块能确保重要的子线程退出后进程才退出。&nbsp;</p>
<p>　　thread模块不支持守护线程，当主线程退出时，所有的子线程不论它们是否还在工作，都会被强行退出。而threading模块支持守护线程，守护线程一般是一个等待客户请求的服务器，如果没有客户提出请求它就在那等着，如果设定一个线程为守护线程，就表示这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。</p>
<h2>threading模块</h2>
<p>multiprocess模块的完全模仿了threading模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍（<a href="https://docs.python.org/3/library/threading.html?highlight=threading#" target="_blank">官方链接</a>）</p>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label10"></a></div>
<h3>线程的创建Threading.Thread类</h3>
<h4>线程的创建</h4>
<div class="cnblogs_code" onclick="cnblogs_code_show('0de93377-d9ea-4ff0-abf9-dbe97056bfcf')"><img id="code_img_closed_0de93377-d9ea-4ff0-abf9-dbe97056bfcf" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_0de93377-d9ea-4ff0-abf9-dbe97056bfcf" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0de93377-d9ea-4ff0-abf9-dbe97056bfcf',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_0de93377-d9ea-4ff0-abf9-dbe97056bfcf" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> sayhi(name):
    time.sleep(</span>2<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s say hello</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    t</span>=Thread(target=sayhi,args=(<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span><span style="color: #000000;">,))
    t.start()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">创建线程的方式1</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('a6b75f83-e66c-4fce-a63a-e486d4508ec5')"><img id="code_img_closed_a6b75f83-e66c-4fce-a63a-e486d4508ec5" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a6b75f83-e66c-4fce-a63a-e486d4508ec5" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a6b75f83-e66c-4fce-a63a-e486d4508ec5',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a6b75f83-e66c-4fce-a63a-e486d4508ec5" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Sayhi(Thread):
    </span><span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span><span style="color: #000000;">(self,name):
        super().</span><span style="color: #800080;">__init__</span><span style="color: #000000;">()
        self.name</span>=<span style="color: #000000;">name
    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> run(self):
        time.sleep(</span>2<span style="color: #000000;">)
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s say hello</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> self.name)


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    t </span>= Sayhi(<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    t.start()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">创建线程的方式2</span></div>
<h4>多线程与多进程</h4>
<div class="cnblogs_code" onclick="cnblogs_code_show('7aa932fd-9215-4081-8b7a-d3f32cf02337')"><img id="code_img_closed_7aa932fd-9215-4081-8b7a-d3f32cf02337" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7aa932fd-9215-4081-8b7a-d3f32cf02337" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7aa932fd-9215-4081-8b7a-d3f32cf02337',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7aa932fd-9215-4081-8b7a-d3f32cf02337" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work():
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hello</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #008000;">#</span><span style="color: #008000;">part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样</span>
    t1=Thread(target=<span style="color: #000000;">work)
    t2</span>=Thread(target=<span style="color: #000000;">work)
    t1.start()
    t2.start()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程/主进程pid</span><span style="color: #800000;">'</span><span style="color: #000000;">,os.getpid())

    </span><span style="color: #008000;">#</span><span style="color: #008000;">part2:开多个进程,每个进程都有不同的pid</span>
    p1=Process(target=<span style="color: #000000;">work)
    p2</span>=Process(target=<span style="color: #000000;">work)
    p1.start()
    p2.start()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程/主进程pid</span><span style="color: #800000;">'</span>,os.getpid())</pre>
</div>
<span class="cnblogs_code_collapse">pid的比较</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('82cae2e4-43bc-40cf-bc32-3877027a52e2')"><img id="code_img_closed_82cae2e4-43bc-40cf-bc32-3877027a52e2" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_82cae2e4-43bc-40cf-bc32-3877027a52e2" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('82cae2e4-43bc-40cf-bc32-3877027a52e2',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_82cae2e4-43bc-40cf-bc32-3877027a52e2" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work():
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hello</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #008000;">#</span><span style="color: #008000;">在主进程下开启线程</span>
    t=Thread(target=<span style="color: #000000;">work)
    t.start()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程/主进程</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    打印结果:
    hello
    主线程/主进程
    </span><span style="color: #800000;">'''</span>

    <span style="color: #008000;">#</span><span style="color: #008000;">在主进程下开启子进程</span>
    t=Process(target=<span style="color: #000000;">work)
    t.start()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程/主进程</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    打印结果:
    主线程/主进程
    hello
    </span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">开启效率的较量</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('ac68cd6b-c49c-48e5-98f3-8fce677ec822')"><img id="code_img_closed_ac68cd6b-c49c-48e5-98f3-8fce677ec822" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_ac68cd6b-c49c-48e5-98f3-8fce677ec822" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ac68cd6b-c49c-48e5-98f3-8fce677ec822',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_ac68cd6b-c49c-48e5-98f3-8fce677ec822" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span>  threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work():
    </span><span style="color: #0000ff;">global</span><span style="color: #000000;"> n
    n</span>=<span style="color: #000000;">0

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #008000;">#</span><span style="color: #008000;"> n=100</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> p=Process(target=work)</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> p.start()</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> p.join()</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> print('主',n) #毫无疑问子进程p已经将自己的全局的n改成了0,但改的仅仅是它自己的,查看父进程的n仍然为100</span>
<span style="color: #000000;">

    n</span>=1<span style="color: #000000;">
    t</span>=Thread(target=<span style="color: #000000;">work)
    t.start()
    t.join()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span>,n) <span style="color: #008000;">#</span><span style="color: #008000;">查看结果为0,因为同一进程内的线程之间共享进程内的数据</span>
同一进程内的线程共享该进程的数据？</pre>
</div>
<span class="cnblogs_code_collapse">内存数据的共享问题</span></div>
<h4>练习 ：多线程实现socket</h4>
<div class="cnblogs_code" onclick="cnblogs_code_show('63f043e2-9e00-4af1-8180-81e41232bb05')"><img id="code_img_closed_63f043e2-9e00-4af1-8180-81e41232bb05" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_63f043e2-9e00-4af1-8180-81e41232bb05" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('63f043e2-9e00-4af1-8180-81e41232bb05',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_63f043e2-9e00-4af1-8180-81e41232bb05" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">_*_coding:utf-8_*_</span><span style="color: #008000;">
#</span><span style="color: #008000;">!/usr/bin/env python</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> multiprocessing
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> threading

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> socket
s</span>=<span style="color: #000000;">socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.bind((</span><span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>,8080<span style="color: #000000;">))
s.listen(</span>5<span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> action(conn):
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        data</span>=conn.recv(1024<span style="color: #000000;">)
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(data)
        conn.send(data.upper())

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:

    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        conn,addr</span>=<span style="color: #000000;">s.accept()


        p</span>=threading.Thread(target=action,args=<span style="color: #000000;">(conn,))
        p.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">server</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('00d3362b-deb9-4f1e-b65e-3cbdd6c2b5b6')"><img id="code_img_closed_00d3362b-deb9-4f1e-b65e-3cbdd6c2b5b6" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_00d3362b-deb9-4f1e-b65e-3cbdd6c2b5b6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('00d3362b-deb9-4f1e-b65e-3cbdd6c2b5b6',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_00d3362b-deb9-4f1e-b65e-3cbdd6c2b5b6" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">_*_coding:utf-8_*_</span><span style="color: #008000;">
#</span><span style="color: #008000;">!/usr/bin/env python</span>


<span style="color: #0000ff;">import</span><span style="color: #000000;"> socket

s</span>=<span style="color: #000000;">socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect((</span><span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>,8080<span style="color: #000000;">))

</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    msg</span>=input(<span style="color: #800000;">'</span><span style="color: #800000;">&gt;&gt;: </span><span style="color: #800000;">'</span><span style="color: #000000;">).strip()
    </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span> msg:<span style="color: #0000ff;">continue</span><span style="color: #000000;">

    s.send(msg.encode(</span><span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    data</span>=s.recv(1024<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(data)</pre>
</div>
<span class="cnblogs_code_collapse">client</span></div>
<h4>Thread类的其他方法</h4>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Thread实例对象的方法
  </span><span style="color: #008000;">#</span><span style="color: #008000;"> isAlive(): 返回线程是否活动的。</span>
  <span style="color: #008000;">#</span><span style="color: #008000;"> getName(): 返回线程名。</span>
  <span style="color: #008000;">#</span><span style="color: #008000;"> setName(): 设置线程名。</span>
<span style="color: #000000;">
threading模块提供的一些方法：
  </span><span style="color: #008000;">#</span><span style="color: #008000;"> threading.currentThread(): 返回当前的线程变量。</span>
  <span style="color: #008000;">#</span><span style="color: #008000;"> threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span>
  <span style="color: #008000;">#</span><span style="color: #008000;"> threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('4e551202-57db-4895-884b-ef47d4210e18')"><img id="code_img_closed_4e551202-57db-4895-884b-ef47d4210e18" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4e551202-57db-4895-884b-ef47d4210e18" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4e551202-57db-4895-884b-ef47d4210e18',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4e551202-57db-4895-884b-ef47d4210e18" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> threading
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Process
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work():
    </span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
    time.sleep(</span>3<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(threading.current_thread().getName())


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #008000;">#</span><span style="color: #008000;">在主进程下开启线程</span>
    t=Thread(target=<span style="color: #000000;">work)
    t.start()

    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(threading.current_thread().getName())
    </span><span style="color: #0000ff;">print</span>(threading.current_thread()) <span style="color: #008000;">#</span><span style="color: #008000;">主线程</span>
    <span style="color: #0000ff;">print</span>(threading.enumerate()) <span style="color: #008000;">#</span><span style="color: #008000;">连同主线程在内有两个运行的线程</span>
    <span style="color: #0000ff;">print</span><span style="color: #000000;">(threading.active_count())
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程/主进程</span><span style="color: #800000;">'</span><span style="color: #000000;">)

    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    打印结果:
    MainThread
    &lt;_MainThread(MainThread, started 140735268892672)&gt;
    [&lt;_MainThread(MainThread, started 140735268892672)&gt;, &lt;Thread(Thread-1, started 123145307557888)&gt;]
    主线程/主进程
    Thread-1
    </span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">代码示例</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('209eab7c-c86d-4a75-a29f-ecba99a5f510')"><img id="code_img_closed_209eab7c-c86d-4a75-a29f-ecba99a5f510" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_209eab7c-c86d-4a75-a29f-ecba99a5f510" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('209eab7c-c86d-4a75-a29f-ecba99a5f510',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_209eab7c-c86d-4a75-a29f-ecba99a5f510" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> sayhi(name):
    time.sleep(</span>2<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s say hello</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    t</span>=Thread(target=sayhi,args=(<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span><span style="color: #000000;">,))
    t.start()
    t.join()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(t.is_alive())
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    egon say hello
    主线程
    False
    </span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">join方法</span></div>
<h4>守护线程</h4>
<p><strong>无论是进程还是线程，都遵循：守护xx会等待主xx运行完毕后被销毁。</strong><strong>需要强调的是：运行完毕并非终止运行</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">1.对主进程来说，运行完毕指的是主进程代码运行完毕</span><span style="color: #008000;">
#</span><span style="color: #008000;">2.对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕</span></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('c9e29e49-17d4-4d80-a378-1fc1b52b44bb')"><img id="code_img_closed_c9e29e49-17d4-4d80-a378-1fc1b52b44bb" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_c9e29e49-17d4-4d80-a378-1fc1b52b44bb" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c9e29e49-17d4-4d80-a378-1fc1b52b44bb',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_c9e29e49-17d4-4d80-a378-1fc1b52b44bb" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">1 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，</span><span style="color: #008000;">
#</span><span style="color: #008000;">2 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。</span></pre>
</div>
<span class="cnblogs_code_collapse">详细解释</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('6ae48500-0236-43b8-84ed-e9f8dd80ed17')"><img id="code_img_closed_6ae48500-0236-43b8-84ed-e9f8dd80ed17" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6ae48500-0236-43b8-84ed-e9f8dd80ed17" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6ae48500-0236-43b8-84ed-e9f8dd80ed17',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6ae48500-0236-43b8-84ed-e9f8dd80ed17" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> sayhi(name):
    time.sleep(</span>2<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s say hello</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    t</span>=Thread(target=sayhi,args=(<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span><span style="color: #000000;">,))
    t.setDaemon(True) </span><span style="color: #008000;">#</span><span style="color: #008000;">必须在t.start()之前设置</span>
<span style="color: #000000;">    t.start()

    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主线程</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(t.is_alive())
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    主线程
    True
    </span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">守护线程例1</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('ce14a2c0-5100-4429-9be3-3b7cb6a1dbad')"><img id="code_img_closed_ce14a2c0-5100-4429-9be3-3b7cb6a1dbad" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_ce14a2c0-5100-4429-9be3-3b7cb6a1dbad" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ce14a2c0-5100-4429-9be3-3b7cb6a1dbad',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_ce14a2c0-5100-4429-9be3-3b7cb6a1dbad" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> foo():
    </span><span style="color: #0000ff;">print</span>(123<span style="color: #000000;">)
    time.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">end123</span><span style="color: #800000;">"</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> bar():
    </span><span style="color: #0000ff;">print</span>(456<span style="color: #000000;">)
    time.sleep(</span>3<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">end456</span><span style="color: #800000;">"</span><span style="color: #000000;">)


t1</span>=Thread(target=<span style="color: #000000;">foo)
t2</span>=Thread(target=<span style="color: #000000;">bar)

t1.daemon</span>=<span style="color: #000000;">True
t1.start()
t2.start()
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">main-------</span><span style="color: #800000;">"</span>)</pre>
</div>
<span class="cnblogs_code_collapse">守护线程例2</span></div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label11"></a></div>
<h3>锁</h3>
<h4>锁与GIL</h4>
<p>&nbsp;</p>
<h4>同步锁</h4>
<div class="cnblogs_code" onclick="cnblogs_code_show('06d17dd4-cab3-4dae-b4c2-0454b81d4cc6')"><img id="code_img_closed_06d17dd4-cab3-4dae-b4c2-0454b81d4cc6" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_06d17dd4-cab3-4dae-b4c2-0454b81d4cc6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('06d17dd4-cab3-4dae-b4c2-0454b81d4cc6',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_06d17dd4-cab3-4dae-b4c2-0454b81d4cc6" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os,time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work():
    </span><span style="color: #0000ff;">global</span><span style="color: #000000;"> n
    temp</span>=<span style="color: #000000;">n
    time.sleep(</span>0.1<span style="color: #000000;">)
    n</span>=temp-1
<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    n</span>=100<span style="color: #000000;">
    l</span>=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100<span style="color: #000000;">):
        p</span>=Thread(target=<span style="color: #000000;">work)
        l.append(p)
        p.start()
    </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> l:
        p.join()

    </span><span style="color: #0000ff;">print</span>(n) <span style="color: #008000;">#</span><span style="color: #008000;">结果可能为99</span></pre>
</div>
<span class="cnblogs_code_collapse">多个线程抢占资源的情况</span></div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> threading
R</span>=<span style="color: #000000;">threading.Lock()
R.acquire()
</span><span style="color: #800000;">'''</span><span style="color: #800000;">
对公共数据的操作
</span><span style="color: #800000;">'''</span><span style="color: #000000;">
R.release()</span></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('fcf3d4bc-7f56-4652-bb78-ca66f14e7f09')"><img id="code_img_closed_fcf3d4bc-7f56-4652-bb78-ca66f14e7f09" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_fcf3d4bc-7f56-4652-bb78-ca66f14e7f09" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fcf3d4bc-7f56-4652-bb78-ca66f14e7f09',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_fcf3d4bc-7f56-4652-bb78-ca66f14e7f09" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread,Lock
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os,time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> work():
    </span><span style="color: #0000ff;">global</span><span style="color: #000000;"> n
    lock.acquire()
    temp</span>=<span style="color: #000000;">n
    time.sleep(</span>0.1<span style="color: #000000;">)
    n</span>=temp-1<span style="color: #000000;">
    lock.release()
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    lock</span>=<span style="color: #000000;">Lock()
    n</span>=100<span style="color: #000000;">
    l</span>=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100<span style="color: #000000;">):
        p</span>=Thread(target=<span style="color: #000000;">work)
        l.append(p)
        p.start()
    </span><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> l:
        p.join()

    </span><span style="color: #0000ff;">print</span>(n) <span style="color: #008000;">#</span><span style="color: #008000;">结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全</span></pre>
</div>
<span class="cnblogs_code_collapse">同步锁的引用</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('6056e103-8290-45cc-ae0c-5389489e28cc')"><img id="code_img_closed_6056e103-8290-45cc-ae0c-5389489e28cc" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6056e103-8290-45cc-ae0c-5389489e28cc" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6056e103-8290-45cc-ae0c-5389489e28cc',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6056e103-8290-45cc-ae0c-5389489e28cc" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">不加锁:并发执行,速度快,数据不安全</span>
<span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> current_thread,Thread,Lock
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os,time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> task():
    </span><span style="color: #0000ff;">global</span><span style="color: #000000;"> n
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s is running</span><span style="color: #800000;">'</span> %<span style="color: #000000;">current_thread().getName())
    temp</span>=<span style="color: #000000;">n
    time.sleep(</span>0.5<span style="color: #000000;">)
    n</span>=temp-1


<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    n</span>=100<span style="color: #000000;">
    lock</span>=<span style="color: #000000;">Lock()
    threads</span>=<span style="color: #000000;">[]
    start_time</span>=<span style="color: #000000;">time.time()
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100<span style="color: #000000;">):
        t</span>=Thread(target=<span style="color: #000000;">task)
        threads.append(t)
        t.start()
    </span><span style="color: #0000ff;">for</span> t <span style="color: #0000ff;">in</span><span style="color: #000000;"> threads:
        t.join()

    stop_time</span>=<span style="color: #000000;">time.time()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主:%s n:%s</span><span style="color: #800000;">'</span> %(stop_time-<span style="color: #000000;">start_time,n))

</span><span style="color: #800000;">'''</span><span style="color: #800000;">
Thread-1 is running
Thread-2 is running
......
Thread-100 is running
主:0.5216062068939209 n:99
</span><span style="color: #800000;">'''</span>


<span style="color: #008000;">#</span><span style="color: #008000;">不加锁:未加锁部分并发执行,加锁部分串行执行,速度慢,数据安全</span>
<span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> current_thread,Thread,Lock
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os,time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> task():
    </span><span style="color: #008000;">#</span><span style="color: #008000;">未加锁的代码并发运行</span>
    time.sleep(3<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s start to run</span><span style="color: #800000;">'</span> %<span style="color: #000000;">current_thread().getName())
    </span><span style="color: #0000ff;">global</span><span style="color: #000000;"> n
    </span><span style="color: #008000;">#</span><span style="color: #008000;">加锁的代码串行运行</span>
<span style="color: #000000;">    lock.acquire()
    temp</span>=<span style="color: #000000;">n
    time.sleep(</span>0.5<span style="color: #000000;">)
    n</span>=temp-1<span style="color: #000000;">
    lock.release()

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    n</span>=100<span style="color: #000000;">
    lock</span>=<span style="color: #000000;">Lock()
    threads</span>=<span style="color: #000000;">[]
    start_time</span>=<span style="color: #000000;">time.time()
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100<span style="color: #000000;">):
        t</span>=Thread(target=<span style="color: #000000;">task)
        threads.append(t)
        t.start()
    </span><span style="color: #0000ff;">for</span> t <span style="color: #0000ff;">in</span><span style="color: #000000;"> threads:
        t.join()
    stop_time</span>=<span style="color: #000000;">time.time()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主:%s n:%s</span><span style="color: #800000;">'</span> %(stop_time-<span style="color: #000000;">start_time,n))

</span><span style="color: #800000;">'''</span><span style="color: #800000;">
Thread-1 is running
Thread-2 is running
......
Thread-100 is running
主:53.294203758239746 n:0
</span><span style="color: #800000;">'''</span>

<span style="color: #008000;">#</span><span style="color: #008000;">有的同学可能有疑问:既然加锁会让运行变成串行,那么我在start之后立即使用join,就不用加锁了啊,也是串行的效果啊</span><span style="color: #008000;">
#</span><span style="color: #008000;">没错:在start之后立刻使用jion,肯定会将100个任务的执行变成串行,毫无疑问,最终n的结果也肯定是0,是安全的,但问题是</span><span style="color: #008000;">
#</span><span style="color: #008000;">start后立即join:任务内的所有代码都是串行执行的,而加锁,只是加锁的部分即修改共享数据的部分是串行的</span><span style="color: #008000;">
#</span><span style="color: #008000;">单从保证数据安全方面,二者都可以实现,但很明显是加锁的效率更高.</span>
<span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> current_thread,Thread,Lock
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os,time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> task():
    time.sleep(</span>3<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s start to run</span><span style="color: #800000;">'</span> %<span style="color: #000000;">current_thread().getName())
    </span><span style="color: #0000ff;">global</span><span style="color: #000000;"> n
    temp</span>=<span style="color: #000000;">n
    time.sleep(</span>0.5<span style="color: #000000;">)
    n</span>=temp-1


<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    n</span>=100<span style="color: #000000;">
    lock</span>=<span style="color: #000000;">Lock()
    start_time</span>=<span style="color: #000000;">time.time()
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100<span style="color: #000000;">):
        t</span>=Thread(target=<span style="color: #000000;">task)
        t.start()
        t.join()
    stop_time</span>=<span style="color: #000000;">time.time()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主:%s n:%s</span><span style="color: #800000;">'</span> %(stop_time-<span style="color: #000000;">start_time,n))

</span><span style="color: #800000;">'''</span><span style="color: #800000;">
Thread-1 start to run
Thread-2 start to run
......
Thread-100 start to run
主:350.6937336921692 n:0 #耗时是多么的恐怖
</span><span style="color: #800000;">'''</span><span style="color: #000000;">

）</span></pre>
</div>
<span class="cnblogs_code_collapse">互斥锁与join的区别</span></div>
<h4>死锁与递归锁</h4>
<p>进程也有死锁与递归锁，在进程那里忘记说了，放到这里一切说了额</p>
<p>所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('33ce2c0d-f6b7-493e-9ac9-aee9caa9c5da')"><img id="code_img_closed_33ce2c0d-f6b7-493e-9ac9-aee9caa9c5da" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_33ce2c0d-f6b7-493e-9ac9-aee9caa9c5da" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('33ce2c0d-f6b7-493e-9ac9-aee9caa9c5da',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_33ce2c0d-f6b7-493e-9ac9-aee9caa9c5da" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Lock as Lock
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
mutexA</span>=<span style="color: #000000;">Lock()
mutexA.acquire()
mutexA.acquire()
</span><span style="color: #0000ff;">print</span>(123<span style="color: #000000;">)
mutexA.release()
mutexA.release()</span></pre>
</div>
<span class="cnblogs_code_collapse">死锁</span></div>
<p>解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。</p>
<p>这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2e2336ce-9371-4408-8d8a-e9ede80440f9')"><img id="code_img_closed_2e2336ce-9371-4408-8d8a-e9ede80440f9" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2e2336ce-9371-4408-8d8a-e9ede80440f9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2e2336ce-9371-4408-8d8a-e9ede80440f9',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2e2336ce-9371-4408-8d8a-e9ede80440f9" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> RLock as Lock
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
mutexA</span>=<span style="color: #000000;">Lock()
mutexA.acquire()
mutexA.acquire()
</span><span style="color: #0000ff;">print</span>(123<span style="color: #000000;">)
mutexA.release()
mutexA.release()</span></pre>
</div>
<span class="cnblogs_code_collapse">递归锁RLock</span></div>
<p>典型问题：科学家吃面</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('32f2a403-7a10-44e3-82bf-4771f2dd2932')"><img id="code_img_closed_32f2a403-7a10-44e3-82bf-4771f2dd2932" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_32f2a403-7a10-44e3-82bf-4771f2dd2932" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('32f2a403-7a10-44e3-82bf-4771f2dd2932',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_32f2a403-7a10-44e3-82bf-4771f2dd2932" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread,Lock
noodle_lock </span>=<span style="color: #000000;"> Lock()
fork_lock </span>=<span style="color: #000000;"> Lock()
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> eat1(name):
    noodle_lock.acquire()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 抢到了面条</span><span style="color: #800000;">'</span>%<span style="color: #000000;">name)
    fork_lock.acquire()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 抢到了叉子</span><span style="color: #800000;">'</span>%<span style="color: #000000;">name)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 吃面</span><span style="color: #800000;">'</span>%<span style="color: #000000;">name)
    fork_lock.release()
    noodle_lock.release()

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> eat2(name):
    fork_lock.acquire()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 抢到了叉子</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> name)
    time.sleep(</span>1<span style="color: #000000;">)
    noodle_lock.acquire()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 抢到了面条</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> name)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 吃面</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> name)
    noodle_lock.release()
    fork_lock.release()

</span><span style="color: #0000ff;">for</span> name <span style="color: #0000ff;">in</span> [<span style="color: #800000;">'</span><span style="color: #800000;">哪吒</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">yuan</span><span style="color: #800000;">'</span><span style="color: #000000;">]:
    t1 </span>= Thread(target=eat1,args=<span style="color: #000000;">(name,))
    t2 </span>= Thread(target=eat2,args=<span style="color: #000000;">(name,))
    t1.start()
    t2.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">死锁问题</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('56d8fc13-64af-4b51-bdbf-a44919c25235')"><img id="code_img_closed_56d8fc13-64af-4b51-bdbf-a44919c25235" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_56d8fc13-64af-4b51-bdbf-a44919c25235" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('56d8fc13-64af-4b51-bdbf-a44919c25235',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_56d8fc13-64af-4b51-bdbf-a44919c25235" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread,RLock
fork_lock </span>= noodle_lock =<span style="color: #000000;"> RLock()
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> eat1(name):
    noodle_lock.acquire()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 抢到了面条</span><span style="color: #800000;">'</span>%<span style="color: #000000;">name)
    fork_lock.acquire()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 抢到了叉子</span><span style="color: #800000;">'</span>%<span style="color: #000000;">name)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 吃面</span><span style="color: #800000;">'</span>%<span style="color: #000000;">name)
    fork_lock.release()
    noodle_lock.release()

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> eat2(name):
    fork_lock.acquire()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 抢到了叉子</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> name)
    time.sleep(</span>1<span style="color: #000000;">)
    noodle_lock.acquire()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 抢到了面条</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> name)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s 吃面</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> name)
    noodle_lock.release()
    fork_lock.release()

</span><span style="color: #0000ff;">for</span> name <span style="color: #0000ff;">in</span> [<span style="color: #800000;">'</span><span style="color: #800000;">哪吒</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">yuan</span><span style="color: #800000;">'</span><span style="color: #000000;">]:
    t1 </span>= Thread(target=eat1,args=<span style="color: #000000;">(name,))
    t2 </span>= Thread(target=eat2,args=<span style="color: #000000;">(name,))
    t1.start()
    t2.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">递归锁解决死锁问题</span></div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label16"></a></div>
<h3>线程队列</h3>
<p>queue队列 ：使用import queue，用法与进程Queue一样</p>
<p>queue is especially useful in threaded programming when information must be exchanged safely between multiple threads.</p>
<dl class="class"><dt id="queue.Queue"><strong><em class="property">class&nbsp;</em><code class="descclassname">queue.</code><code class="descname">Queue</code><span class="sig-paren">(<em>maxsize=0</em><span class="sig-paren">) #先进先出</span></span></strong></dt><dt></dt></dl>
<div class="cnblogs_code" onclick="cnblogs_code_show('d8cf53cc-1cb7-4b4d-bf6f-0ef1a9a4a5e7')"><img id="code_img_closed_d8cf53cc-1cb7-4b4d-bf6f-0ef1a9a4a5e7" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d8cf53cc-1cb7-4b4d-bf6f-0ef1a9a4a5e7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d8cf53cc-1cb7-4b4d-bf6f-0ef1a9a4a5e7',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d8cf53cc-1cb7-4b4d-bf6f-0ef1a9a4a5e7" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> queue

q</span>=<span style="color: #000000;">queue.Queue()
q.put(</span><span style="color: #800000;">'</span><span style="color: #800000;">first</span><span style="color: #800000;">'</span><span style="color: #000000;">)
q.put(</span><span style="color: #800000;">'</span><span style="color: #800000;">second</span><span style="color: #800000;">'</span><span style="color: #000000;">)
q.put(</span><span style="color: #800000;">'</span><span style="color: #800000;">third</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #800000;">'''</span><span style="color: #800000;">
结果(先进先出):
first
second
third
</span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">先进先出</span></div>
<p><strong><em class="property">class&nbsp;</em><code class="descclassname">queue.</code><code class="descname">LifoQueue</code><span class="sig-paren">(<em>maxsize=0</em><span class="sig-paren">) #last in fisrt out</span></span></strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fdcedfe6-b33e-4c37-8eb4-86c04efaa9a1')"><img id="code_img_closed_fdcedfe6-b33e-4c37-8eb4-86c04efaa9a1" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_fdcedfe6-b33e-4c37-8eb4-86c04efaa9a1" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fdcedfe6-b33e-4c37-8eb4-86c04efaa9a1',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_fdcedfe6-b33e-4c37-8eb4-86c04efaa9a1" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> queue

q</span>=<span style="color: #000000;">queue.LifoQueue()
q.put(</span><span style="color: #800000;">'</span><span style="color: #800000;">first</span><span style="color: #800000;">'</span><span style="color: #000000;">)
q.put(</span><span style="color: #800000;">'</span><span style="color: #800000;">second</span><span style="color: #800000;">'</span><span style="color: #000000;">)
q.put(</span><span style="color: #800000;">'</span><span style="color: #800000;">third</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #800000;">'''</span><span style="color: #800000;">
结果(后进先出):
third
second
first
</span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">后进先出</span></div>
<p><strong><em class="property">class&nbsp;</em><code class="descclassname">queue.</code><code class="descname">PriorityQueue</code><span class="sig-paren">(<em>maxsize=0</em><span class="sig-paren">) #存储数据时可设置优先级的队列</span></span></strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5c1846d7-735d-4909-b859-17ba8480f94f')"><img id="code_img_closed_5c1846d7-735d-4909-b859-17ba8480f94f" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5c1846d7-735d-4909-b859-17ba8480f94f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5c1846d7-735d-4909-b859-17ba8480f94f',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5c1846d7-735d-4909-b859-17ba8480f94f" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> queue

q</span>=<span style="color: #000000;">queue.PriorityQueue()
</span><span style="color: #008000;">#</span><span style="color: #008000;">put进入一个元组,元组的第一个元素是优先级(通常是数字,也可以是非数字之间的比较),数字越小优先级越高</span>
q.put((20,<span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">))
q.put((</span>10,<span style="color: #800000;">'</span><span style="color: #800000;">b</span><span style="color: #800000;">'</span><span style="color: #000000;">))
q.put((</span>30,<span style="color: #800000;">'</span><span style="color: #800000;">c</span><span style="color: #800000;">'</span><span style="color: #000000;">))

</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(q.get())
</span><span style="color: #800000;">'''</span><span style="color: #800000;">
结果(数字越小优先级越高,优先级高的优先出队):
(10, 'b')
(20, 'a')
(30, 'c')
</span><span style="color: #800000;">'''</span></pre>
</div>
<span class="cnblogs_code_collapse">优先级队列</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('b148ee8e-6c38-4742-947b-6ba9852ed601')"><img id="code_img_closed_b148ee8e-6c38-4742-947b-6ba9852ed601" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b148ee8e-6c38-4742-947b-6ba9852ed601" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b148ee8e-6c38-4742-947b-6ba9852ed601',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b148ee8e-6c38-4742-947b-6ba9852ed601" class="cnblogs_code_hide">
<pre>Constructor <span style="color: #0000ff;">for</span> a priority queue. maxsize <span style="color: #0000ff;">is</span> an integer that sets the upperbound limit on the number of items that can be placed <span style="color: #0000ff;">in</span> the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize <span style="color: #0000ff;">is</span> less than <span style="color: #0000ff;">or</span> equal to zero, the queue size <span style="color: #0000ff;">is</span><span style="color: #000000;"> infinite.

The lowest valued entries are retrieved first (the lowest valued entry </span><span style="color: #0000ff;">is</span> the one returned by sorted(list(entries))[0]). A typical pattern <span style="color: #0000ff;">for</span> entries <span style="color: #0000ff;">is</span> a tuple <span style="color: #0000ff;">in</span><span style="color: #000000;"> the form: (priority_number, data).

exception queue.Empty
Exception raised when non</span>-blocking get() (<span style="color: #0000ff;">or</span> get_nowait()) <span style="color: #0000ff;">is</span> called on a Queue object which <span style="color: #0000ff;">is</span><span style="color: #000000;"> empty.

exception queue.Full
Exception raised when non</span>-blocking put() (<span style="color: #0000ff;">or</span> put_nowait()) <span style="color: #0000ff;">is</span> called on a Queue object which <span style="color: #0000ff;">is</span><span style="color: #000000;"> full.

Queue.qsize()
Queue.empty() </span><span style="color: #008000;">#</span><span style="color: #008000;">return True if empty  </span>
Queue.full() <span style="color: #008000;">#</span><span style="color: #008000;"> return True if full </span>
Queue.put(item, block=True, timeout=<span style="color: #000000;">None)
Put item into the queue. If optional args block </span><span style="color: #0000ff;">is</span> true <span style="color: #0000ff;">and</span> timeout <span style="color: #0000ff;">is</span> None (the default), block <span style="color: #0000ff;">if</span> necessary until a free slot <span style="color: #0000ff;">is</span> available. If timeout <span style="color: #0000ff;">is</span> a positive number, it blocks at most timeout seconds <span style="color: #0000ff;">and</span> raises the Full exception <span style="color: #0000ff;">if</span> no free slot was available within that time. Otherwise (block <span style="color: #0000ff;">is</span> false), put an item on the queue <span style="color: #0000ff;">if</span> a free slot <span style="color: #0000ff;">is</span> immediately available, <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">raise</span> the Full exception (timeout <span style="color: #0000ff;">is</span> ignored <span style="color: #0000ff;">in</span><span style="color: #000000;"> that case).

Queue.put_nowait(item)
Equivalent to put(item, False).

Queue.get(block</span>=True, timeout=<span style="color: #000000;">None)
Remove </span><span style="color: #0000ff;">and</span> <span style="color: #0000ff;">return</span> an item <span style="color: #0000ff;">from</span> the queue. If optional args block <span style="color: #0000ff;">is</span> true <span style="color: #0000ff;">and</span> timeout <span style="color: #0000ff;">is</span> None (the default), block <span style="color: #0000ff;">if</span> necessary until an item <span style="color: #0000ff;">is</span> available. If timeout <span style="color: #0000ff;">is</span> a positive number, it blocks at most timeout seconds <span style="color: #0000ff;">and</span> raises the Empty exception <span style="color: #0000ff;">if</span> no item was available within that time. Otherwise (block <span style="color: #0000ff;">is</span> false), <span style="color: #0000ff;">return</span> an item <span style="color: #0000ff;">if</span> one <span style="color: #0000ff;">is</span> immediately available, <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">raise</span> the Empty exception (timeout <span style="color: #0000ff;">is</span> ignored <span style="color: #0000ff;">in</span><span style="color: #000000;"> that case).

Queue.get_nowait()
Equivalent to get(False).

Two methods are offered to support tracking whether enqueued tasks have been fully processed by daemon consumer threads.

Queue.task_done()
Indicate that a formerly enqueued task </span><span style="color: #0000ff;">is</span> complete. Used by queue consumer threads. For each get() used to fetch a task, a subsequent call to task_done() tells the queue that the processing on the task <span style="color: #0000ff;">is</span><span style="color: #000000;"> complete.

If a join() </span><span style="color: #0000ff;">is</span> currently blocking, it will resume when all items have been processed (meaning that a task_done() call was received <span style="color: #0000ff;">for</span><span style="color: #000000;"> every item that had been put() into the queue).

Raises a ValueError </span><span style="color: #0000ff;">if</span> called more times than there were items placed <span style="color: #0000ff;">in</span><span style="color: #000000;"> the queue.

Queue.join() block直到queue被消费完毕</span></pre>
</div>
<span class="cnblogs_code_collapse">更多方法说明</span></div>
<div style="text-align: right;"><a href="#_labelTop">回到顶部</a><a name="_label17"></a></div>
<h3>Python标准模块--concurrent.futures</h3>
<p><strong><a href="https://docs.python.org/dev/library/concurrent.futures.html" target="_blank">https://docs.python.org/dev/library/concurrent.futures.html</a></strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">1 介绍</span>
<span style="color: #000000;">concurrent.futures模块提供了高度封装的异步调用接口
ThreadPoolExecutor：线程池，提供异步调用
ProcessPoolExecutor: 进程池，提供异步调用
Both implement the same interface, which </span><span style="color: #0000ff;">is</span> defined by the abstract Executor <span style="color: #0000ff;">class</span><span style="color: #000000;">.

</span><span style="color: #008000;">#</span><span style="color: #008000;">2 基本方法</span><span style="color: #008000;">
#</span><span style="color: #008000;">submit(fn, *args, **kwargs)</span>
<span style="color: #000000;">异步提交任务

</span><span style="color: #008000;">#</span><span style="color: #008000;">map(func, *iterables, timeout=None, chunksize=1) </span>
<span style="color: #000000;">取代for循环submit的操作

</span><span style="color: #008000;">#</span><span style="color: #008000;">shutdown(wait=True) </span>
相当于进程池的pool.close()+<span style="color: #000000;">pool.join()操作
wait</span>=<span style="color: #000000;">True，等待池内所有任务执行完毕回收完资源后才继续
wait</span>=<span style="color: #000000;">False，立即返回，并不会等待池内的任务执行完毕
但不管wait参数为何值，整个程序都会等到所有任务执行完毕
submit和map必须在shutdown之前

</span><span style="color: #008000;">#</span><span style="color: #008000;">result(timeout=None)</span>
<span style="color: #000000;">取得结果

</span><span style="color: #008000;">#</span><span style="color: #008000;">add_done_callback(fn)</span>
回调函数<br /><br /><span style="color: #008000;"># done()</span><br />判断某一个线程是否完成<br /><br /><span style="color: #008000;"># cancle()</span><br />取消某个任务<br /><br /><br /></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('c434c5a3-c904-4946-906c-5adab0ade85a')"><img id="code_img_closed_c434c5a3-c904-4946-906c-5adab0ade85a" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_c434c5a3-c904-4946-906c-5adab0ade85a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c434c5a3-c904-4946-906c-5adab0ade85a',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_c434c5a3-c904-4946-906c-5adab0ade85a" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">介绍</span>
The ProcessPoolExecutor <span style="color: #0000ff;">class</span> <span style="color: #0000ff;">is</span> an Executor subclass that uses a pool of processes to execute calls asynchronously. ProcessPoolExecutor uses the multiprocessing module, which allows it to side-step the Global Interpreter Lock but also means that only picklable objects can be executed <span style="color: #0000ff;">and</span><span style="color: #000000;"> returned.

</span><span style="color: #0000ff;">class</span> concurrent.futures.ProcessPoolExecutor(max_workers=None, mp_context=<span style="color: #000000;">None)
An Executor subclass that executes calls asynchronously using a pool of at most max_workers processes. If max_workers </span><span style="color: #0000ff;">is</span> None <span style="color: #0000ff;">or</span> <span style="color: #0000ff;">not</span> given, it will default to the number of processors on the machine. If max_workers <span style="color: #0000ff;">is</span> lower <span style="color: #0000ff;">or</span><span style="color: #000000;"> equal to 0, then a ValueError will be raised.


</span><span style="color: #008000;">#</span><span style="color: #008000;">用法</span>
<span style="color: #0000ff;">from</span> concurrent.futures <span style="color: #0000ff;">import</span><span style="color: #000000;"> ThreadPoolExecutor,ProcessPoolExecutor

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os,time,random
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> task(n):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s is runing</span><span style="color: #800000;">'</span> %<span style="color: #000000;">os.getpid())
    time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
    </span><span style="color: #0000ff;">return</span> n**2

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:

    executor</span>=ProcessPoolExecutor(max_workers=3<span style="color: #000000;">)

    futures</span>=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(11<span style="color: #000000;">):
        future</span>=<span style="color: #000000;">executor.submit(task,i)
        futures.append(future)
    executor.shutdown(True)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">+++&gt;</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">for</span> future <span style="color: #0000ff;">in</span><span style="color: #000000;"> futures:
        </span><span style="color: #0000ff;">print</span>(future.result())</pre>
</div>
<span class="cnblogs_code_collapse">ProcessPoolExecutor</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('c6114d66-aede-4cb0-871c-562d2a5e7d5a')"><img id="code_img_closed_c6114d66-aede-4cb0-871c-562d2a5e7d5a" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_c6114d66-aede-4cb0-871c-562d2a5e7d5a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c6114d66-aede-4cb0-871c-562d2a5e7d5a',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_c6114d66-aede-4cb0-871c-562d2a5e7d5a" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">介绍</span>
ThreadPoolExecutor <span style="color: #0000ff;">is</span><span style="color: #000000;"> an Executor subclass that uses a pool of threads to execute calls asynchronously.
</span><span style="color: #0000ff;">class</span> concurrent.futures.ThreadPoolExecutor(max_workers=None, thread_name_prefix=<span style="color: #800000;">''</span><span style="color: #000000;">)
An Executor subclass that uses a pool of at most max_workers threads to execute calls asynchronously.

Changed </span><span style="color: #0000ff;">in</span> version 3.5: If max_workers <span style="color: #0000ff;">is</span> None <span style="color: #0000ff;">or</span> <span style="color: #0000ff;">not</span> given, it will default to the number of processors on the machine, multiplied by 5, assuming that ThreadPoolExecutor <span style="color: #0000ff;">is</span> often used to overlap I/O instead of CPU work <span style="color: #0000ff;">and</span> the number of workers should be higher than the number of workers <span style="color: #0000ff;">for</span><span style="color: #000000;"> ProcessPoolExecutor.

New </span><span style="color: #0000ff;">in</span> version 3.6: The thread_name_prefix argument was added to allow users to control the threading.Thread names <span style="color: #0000ff;">for</span> worker threads created by the pool <span style="color: #0000ff;">for</span><span style="color: #000000;"> easier debugging.

</span><span style="color: #008000;">#</span><span style="color: #008000;">用法</span>
与ProcessPoolExecutor相同</pre>
</div>
<span class="cnblogs_code_collapse">ThreadPoolExecutor</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('b0a52570-5a24-4f29-95d4-37de5107d144')"><img id="code_img_closed_b0a52570-5a24-4f29-95d4-37de5107d144" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b0a52570-5a24-4f29-95d4-37de5107d144" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b0a52570-5a24-4f29-95d4-37de5107d144',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b0a52570-5a24-4f29-95d4-37de5107d144" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> concurrent.futures <span style="color: #0000ff;">import</span><span style="color: #000000;"> ThreadPoolExecutor,ProcessPoolExecutor

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os,time,random
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> task(n):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s is runing</span><span style="color: #800000;">'</span> %<span style="color: #000000;">os.getpid())
    time.sleep(random.randint(</span>1,3<span style="color: #000000;">))
    </span><span style="color: #0000ff;">return</span> n**2

<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:

    executor</span>=ThreadPoolExecutor(max_workers=3<span style="color: #000000;">)

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> for i in range(11):</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">     future=executor.submit(task,i)</span>
<span style="color: #000000;">
    executor.map(task,range(</span>1,12)) <span style="color: #008000;">#</span><span style="color: #008000;">map取代了for+submit</span></pre>
</div>
<span class="cnblogs_code_collapse">map的用法</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('61357f79-be7d-4392-a242-fe5855b8ef68')"><img id="code_img_closed_61357f79-be7d-4392-a242-fe5855b8ef68" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_61357f79-be7d-4392-a242-fe5855b8ef68" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('61357f79-be7d-4392-a242-fe5855b8ef68',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_61357f79-be7d-4392-a242-fe5855b8ef68" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> concurrent.futures <span style="color: #0000ff;">import</span><span style="color: #000000;"> ThreadPoolExecutor,ProcessPoolExecutor
</span><span style="color: #0000ff;">from</span> multiprocessing <span style="color: #0000ff;">import</span><span style="color: #000000;"> Pool
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> requests
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> json
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> os

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get_page(url):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">&lt;进程%s&gt; get %s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(os.getpid(),url))
    respone</span>=<span style="color: #000000;">requests.get(url)
    </span><span style="color: #0000ff;">if</span> respone.status_code == 200<span style="color: #000000;">:
        </span><span style="color: #0000ff;">return</span> {<span style="color: #800000;">'</span><span style="color: #800000;">url</span><span style="color: #800000;">'</span>:url,<span style="color: #800000;">'</span><span style="color: #800000;">text</span><span style="color: #800000;">'</span><span style="color: #000000;">:respone.text}

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> parse_page(res):
    res</span>=<span style="color: #000000;">res.result()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">&lt;进程%s&gt; parse %s</span><span style="color: #800000;">'</span> %(os.getpid(),res[<span style="color: #800000;">'</span><span style="color: #800000;">url</span><span style="color: #800000;">'</span><span style="color: #000000;">]))
    parse_res</span>=<span style="color: #800000;">'</span><span style="color: #800000;">url:&lt;%s&gt; size:[%s]\n</span><span style="color: #800000;">'</span> %(res[<span style="color: #800000;">'</span><span style="color: #800000;">url</span><span style="color: #800000;">'</span>],len(res[<span style="color: #800000;">'</span><span style="color: #800000;">text</span><span style="color: #800000;">'</span><span style="color: #000000;">]))
    with open(</span><span style="color: #800000;">'</span><span style="color: #800000;">db.txt</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">) as f:
        f.write(parse_res)


</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    urls</span>=<span style="color: #000000;">[
        </span><span style="color: #800000;">'</span><span style="color: #800000;">https://www.baidu.com</span><span style="color: #800000;">'</span><span style="color: #000000;">,
        </span><span style="color: #800000;">'</span><span style="color: #800000;">https://www.python.org</span><span style="color: #800000;">'</span><span style="color: #000000;">,
        </span><span style="color: #800000;">'</span><span style="color: #800000;">https://www.openstack.org</span><span style="color: #800000;">'</span><span style="color: #000000;">,
        </span><span style="color: #800000;">'</span><span style="color: #800000;">https://help.github.com/</span><span style="color: #800000;">'</span><span style="color: #000000;">,
        </span><span style="color: #800000;">'</span><span style="color: #800000;">http://www.sina.com.cn/</span><span style="color: #800000;">'</span><span style="color: #000000;">
    ]

    </span><span style="color: #008000;">#</span><span style="color: #008000;"> p=Pool(3)</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> for url in urls:</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">     p.apply_async(get_page,args=(url,),callback=pasrse_page)</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> p.close()</span>
    <span style="color: #008000;">#</span><span style="color: #008000;"> p.join()</span>
<span style="color: #000000;">
    p</span>=ProcessPoolExecutor(3<span style="color: #000000;">)
    </span><span style="color: #0000ff;">for</span> url <span style="color: #0000ff;">in</span><span style="color: #000000;"> urls:
        p.submit(get_page,url).add_done_callback(parse_page) </span><span style="color: #008000;">#</span><span style="color: #008000;">parse_page拿到的是一个future对象obj，需要用obj.result()拿到结果</span></pre>
</div>
<span class="cnblogs_code_collapse">回调函数</span></div>
<p>&nbsp;</p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2018-01-21 15:22</span> <a href='https://www.cnblogs.com/Eva-J/'>Eva_J</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>) &nbsp;<a href="https://i.cnblogs.com/EditArticles.aspx?postid=8306047" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8306047);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=250832,cb_entryId=8306047,cb_blogApp=currentBlogApp,cb_blogUserGuid='4997edaa-857b-e511-9fc1-ac853d9f53cc',cb_entryCreatedDate='2018/1/21 15:22:00';loadViewCount(cb_entryId);var cb_postType=2;var isMarkdown=false;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>
<script>
  googletag.cmd.push(function() {
        googletag.defineSlot('/1090369/C1', [300, 250], 'div-gpt-ad-1546353474406-0').addService(googletag.pubads());
        googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
  });
</script>
<div id='cnblogs_c1' class='c_ad_block'>
    <div id='div-gpt-ad-1546353474406-0' style='height:250px; width:300px;'></div>
</div>
<div id='under_post_news'></div>
<div id='cnblogs_c2' class='c_ad_block'>
    <div id='div-gpt-ad-1539008685004-0' style='height:60px; width:468px;'></div>
</div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
 if(enablePostBottom()) {
    codeHighlight();
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverT2();
    deliverC1();
    deliverC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);  
}
</script>
</div>

    
	</div><!--end: topicList 文章列表容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="calendar"><div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script></div>
			
			<DIV id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</DIV>
			
		</div><!--end: sideBarMain -->
		<div class="clear"></div>
		<div id="footer">
			
<!--done-->
Copyright &copy;2019 Eva_J
		</div><!--end: footer -->
	</div><!--end: sideBar 侧边栏容器 -->
</div><!--end: home 自定义的最大容器 -->
</center>

</body>
</html>
