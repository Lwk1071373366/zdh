<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="referrer" content="origin" />
    <title>python之路——协程 - Eva_J - 博客园</title>
<meta property="og:description" content="阅读目录 一 引子 二 协程介绍 三 Greenlet模块 四 Gevent模块 引子 之前我们学习了线程、进程的概念，了解了在操作系统中进程是资源分配的最小单位,线程是CPU调度的最小单位。按道理来" />
    <link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=svlZeZMvc3He7PqOD4T7SOuQn0_kIfLBYiy3idqd35Y1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/LoveIsIntheAir/bundle-LoveIsIntheAir.css?v=1a1njKMb9NXq0SiMQC1DxNR7neAOH_-_T7CqiC-KPw41"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/250832.css?v=sgnWqV5WAgR4lMmYSWvpJe19YwI%3d"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/LoveIsIntheAir/bundle-LoveIsIntheAir-mobile.css?v=2vKssTQro2c1xn1VJpQlerpUCrPsZu0FDfkhm7xMpkY1"/>
    <link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/Eva-J/rss"/>
    <link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/Eva-J/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/Eva-J/wlwmanifest.xml"/>
    <script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script>var currentBlogId=250832;var currentBlogApp='Eva-J',cb_enable_mathjax=false;var isLogined=false;</script>
    <script src="/bundles/blog-common.js?v=OFBZTzkHKauV7mtIFLF9jlqrX-sesK9-mY9KjurLrq01" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<!--PageBeginHtml Block Begin-->
<h2 style="line-height: 1.5em; float: left; text-align: right; color: #816d65; position: absolute; top: 110px; left: 110px; background: #d2eef4">程序媛</h2>
<!--PageBeginHtml Block End-->

<!--done-->
<center>
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/Eva-J/"><img id="blogLogo" src="/Skins/LoveIsIntheAir/images/logo.gif" alt="" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/Eva-J/">Eva_J</a></h1>
<h2></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
	<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
	<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/Eva-J/">首页</a></li>
	<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
	<li><a id="blog_nav_contact" accesskey="9" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/Eva_J">联系</a></li>
	<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
	<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/Eva-J/rss">订阅</a>
	<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/Eva-J/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<!--done-->
随笔- 32&nbsp;
文章- 124&nbsp;
评论- 268&nbsp;
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div class="clear"></div>
	<div id="topicList">
		
        <div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/Eva-J/articles/8324673.html">python之路——协程</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><h1><strong>阅读目录</strong></h1>
<ul>
<li>一 引子</li>
<li>二 协程介绍</li>
<li>三 Greenlet模块</li>
<li>四 Gevent模块</li>
</ul>
<h1>引子</h1>
<p>　　之前我们学习了线程、进程的概念，了解了在操作系统中<strong>进程是资源分配的最小单位,线程是CPU调度的最小单位。</strong>按道理来说我们已经算是把cpu的利用率提高很多了。但是我们知道无论是创建多进程还是创建多线程来解决问题，都要消耗一定的时间来创建进程、创建线程、以及管理他们之间的切换。</p>
<p>　　随着我们对于效率的追求不断提高，<strong>基于单线程来实现并发</strong>又成为一个新的课题，即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并发。这样就可以节省创建线进程所消耗的时间。</p>
<p>　　为此我们需要先回顾下并发的本质：切换+保存状态</p>
<p>&nbsp;　　cpu正在运行一个任务，会在两种情况下切走去执行其他的任务（切换由操作系统强制控制），一种情况是该任务发生了阻塞，另外一种情况是该任务计算的时间过长</p>
<p>　&nbsp; 　<img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180121163441646-1111651857.png" alt="" /></p>
<p>　　ps：在介绍进程理论时，提及进程的三种执行状态，而线程才是执行单位，所以也可以将上图理解为线程的三种状态&nbsp;</p>
<p>　　&nbsp;一：其中第二种情况并不能提升效率，只是为了让cpu能够雨露均沾，实现看起来所有任务都被&ldquo;同时&rdquo;执行的效果，如果多个任务都是纯计算的，这种切换反而会降低效率。</p>
<p>　　为此我们可以基于yield来验证。yield本身就是一种在单线程下可以保存任务运行状态的方法，我们来简单复习一下：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">1 yiled可以保存状态，yield的状态保存与操作系统的保存线程状态很像，但是yield是代码级别控制的，更轻量级</span><span style="color: #008000;">
#</span><span style="color: #008000;">2 send可以把一个函数的结果传给另外一个函数，以此实现单线程内程序之间的切换</span></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('5dcc617c-9a6e-4d73-9400-5051829ef528')"><img id="code_img_closed_5dcc617c-9a6e-4d73-9400-5051829ef528" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5dcc617c-9a6e-4d73-9400-5051829ef528" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5dcc617c-9a6e-4d73-9400-5051829ef528',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5dcc617c-9a6e-4d73-9400-5051829ef528" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">串行执行</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer(res):
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">任务1:接收数据,处理数据</span><span style="color: #800000;">'''</span>
    <span style="color: #0000ff;">pass</span>

<span style="color: #0000ff;">def</span><span style="color: #000000;"> producer():
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">任务2:生产数据</span><span style="color: #800000;">'''</span><span style="color: #000000;">
    res</span>=<span style="color: #000000;">[]
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10000000<span style="color: #000000;">):
        res.append(i)
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res

start</span>=<span style="color: #000000;">time.time()
</span><span style="color: #008000;">#</span><span style="color: #008000;">串行执行</span>
res=<span style="color: #000000;">producer()
consumer(res) </span><span style="color: #008000;">#</span><span style="color: #008000;">写成consumer(producer())会降低执行效率</span>
stop=<span style="color: #000000;">time.time()
</span><span style="color: #0000ff;">print</span>(stop-start) <span style="color: #008000;">#</span><span style="color: #008000;">1.5536692142486572</span>



<span style="color: #008000;">#</span><span style="color: #008000;">基于yield并发执行</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer():
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">任务1:接收数据,处理数据</span><span style="color: #800000;">'''</span>
    <span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        x</span>=<span style="color: #0000ff;">yield</span>

<span style="color: #0000ff;">def</span><span style="color: #000000;"> producer():
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">任务2:生产数据</span><span style="color: #800000;">'''</span><span style="color: #000000;">
    g</span>=<span style="color: #000000;">consumer()
    next(g)
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10000000<span style="color: #000000;">):
        g.send(i)

start</span>=<span style="color: #000000;">time.time()
</span><span style="color: #008000;">#</span><span style="color: #008000;">基于yield保存状态,实现两个任务直接来回切换,即并发的效果</span><span style="color: #008000;">
#</span><span style="color: #008000;">PS:如果每个任务中都加上打印,那么明显地看到两个任务的打印是你一次我一次,即并发执行的.</span>
<span style="color: #000000;">producer()

stop</span>=<span style="color: #000000;">time.time()
</span><span style="color: #0000ff;">print</span>(stop-start) <span style="color: #008000;">#</span><span style="color: #008000;">2.0272178649902344</span></pre>
</div>
<span class="cnblogs_code_collapse">单纯地切换反而会降低运行效率</span></div>
<p>　　二：第一种情况的切换。在任务一遇到io情况下，切到任务二去执行，这样就可以利用任务一阻塞的时间完成任务二的计算，效率的提升就在于此。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fdc60bb8-aabe-4c82-8096-734a0814ce5d')"><img id="code_img_closed_fdc60bb8-aabe-4c82-8096-734a0814ce5d" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_fdc60bb8-aabe-4c82-8096-734a0814ce5d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fdc60bb8-aabe-4c82-8096-734a0814ce5d',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_fdc60bb8-aabe-4c82-8096-734a0814ce5d" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> consumer():
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">任务1:接收数据,处理数据</span><span style="color: #800000;">'''</span>
    <span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        x</span>=<span style="color: #0000ff;">yield</span>

<span style="color: #0000ff;">def</span><span style="color: #000000;"> producer():
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">任务2:生产数据</span><span style="color: #800000;">'''</span><span style="color: #000000;">
    g</span>=<span style="color: #000000;">consumer()
    next(g)
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10000000<span style="color: #000000;">):
        g.send(i)
        time.sleep(</span>2<span style="color: #000000;">)

start</span>=<span style="color: #000000;">time.time()
producer() </span><span style="color: #008000;">#</span><span style="color: #008000;">并发执行,但是任务producer遇到io就会阻塞住,并不会切到该线程内的其他任务去执行</span>
<span style="color: #000000;">
stop</span>=<span style="color: #000000;">time.time()
</span><span style="color: #0000ff;">print</span>(stop-start)</pre>
</div>
<span class="cnblogs_code_collapse">yield无法做到遇到io阻塞</span></div>
<p><strong>　　对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下的多个任务能在一个任务遇到io阻塞时就切换到另外一个任务去计算，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，从而可以迷惑操作系统，让其看到：该线程好像是一直在计算，io比较少，从而更多的将cpu的执行权限分配给我们的线程。</strong></p>
<p>&nbsp; &nbsp; 协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。为了实现它，我们需要找寻一种可以同时满足以下条件的解决方案：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">1. 可以控制多个任务之间的切换，切换之前将任务的状态保存下来，以便重新运行时，可以基于暂停的位置继续执行。</span><span style="color: #008000;">
#</span><span style="color: #008000;">2. 作为1的补充：可以检测io操作，在遇到io操作的情况下才发生切换</span></pre>
</div>
<p>&nbsp;</p>
<h1>协程介绍</h1>
<p>协程：是单线程下的并发，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：<strong>协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。、</strong></p>
<p>需要强调的是：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">1. python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）</span><span style="color: #008000;">
#</span><span style="color: #008000;">2. 单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）</span></pre>
</div>
<p>对比操作系统控制线程的切换，用户在单线程内控制协程的切换</p>
<p>优点如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">1. 协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级</span><span style="color: #008000;">
#</span><span style="color: #008000;">2. 单线程内就可以实现并发的效果，最大限度地利用cpu</span></pre>
</div>
<p>缺点如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">1. 协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程</span><span style="color: #008000;">
#</span><span style="color: #008000;">2. 协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程</span></pre>
</div>
<p>总结协程特点：</p>
<ol>
<li><strong>必须在只有一个单线程里实现并发</strong></li>
<li><strong>修改共享数据不需加锁</strong></li>
<li><strong>用户程序里自己保存多个控制流的上下文栈</strong></li>
<li><strong>附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））</strong></li>
</ol>
<h1>Greenlet模块</h1>
<p>安装 ：pip3 install greenlet</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('074a6ac4-cb40-43ae-a135-98141751dcbf')"><img id="code_img_closed_074a6ac4-cb40-43ae-a135-98141751dcbf" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_074a6ac4-cb40-43ae-a135-98141751dcbf" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('074a6ac4-cb40-43ae-a135-98141751dcbf',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_074a6ac4-cb40-43ae-a135-98141751dcbf" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> greenlet <span style="color: #0000ff;">import</span><span style="color: #000000;"> greenlet

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> eat(name):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s eat 1</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)
    g2.switch(</span><span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s eat 2</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)
    g2.switch()
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> play(name):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s play 1</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)
    g1.switch()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s play 2</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)

g1</span>=<span style="color: #000000;">greenlet(eat)
g2</span>=<span style="color: #000000;">greenlet(play)

g1.switch(</span><span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span>)<span style="color: #008000;">#</span><span style="color: #008000;">可以在第一次switch时传入参数，以后都不需要</span></pre>
</div>
<span class="cnblogs_code_collapse">greenlet实现状态切换</span></div>
<p>单纯的切换（在没有io的情况下或者没有重复开辟内存空间的操作），反而会降低程序的执行速度</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('7e6ab12e-7ce8-493f-bf45-eb5a4382a200')"><img id="code_img_closed_7e6ab12e-7ce8-493f-bf45-eb5a4382a200" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7e6ab12e-7ce8-493f-bf45-eb5a4382a200" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7e6ab12e-7ce8-493f-bf45-eb5a4382a200',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7e6ab12e-7ce8-493f-bf45-eb5a4382a200" class="cnblogs_code_hide">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">顺序执行</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f1():
    res</span>=1
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100000000<span style="color: #000000;">):
        res</span>+=<span style="color: #000000;">i

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f2():
    res</span>=1
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100000000<span style="color: #000000;">):
        res</span>*=<span style="color: #000000;">i

start</span>=<span style="color: #000000;">time.time()
f1()
f2()
stop</span>=<span style="color: #000000;">time.time()
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">run time is %s</span><span style="color: #800000;">'</span> %(stop-start)) <span style="color: #008000;">#</span><span style="color: #008000;">10.985628366470337</span>

<span style="color: #008000;">#</span><span style="color: #008000;">切换</span>
<span style="color: #0000ff;">from</span> greenlet <span style="color: #0000ff;">import</span><span style="color: #000000;"> greenlet
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f1():
    res</span>=1
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100000000<span style="color: #000000;">):
        res</span>+=<span style="color: #000000;">i
        g2.switch()

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> f2():
    res</span>=1
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(100000000<span style="color: #000000;">):
        res</span>*=<span style="color: #000000;">i
        g1.switch()

start</span>=<span style="color: #000000;">time.time()
g1</span>=<span style="color: #000000;">greenlet(f1)
g2</span>=<span style="color: #000000;">greenlet(f2)
g1.switch()
stop</span>=<span style="color: #000000;">time.time()
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">run time is %s</span><span style="color: #800000;">'</span> %(stop-start)) <span style="color: #008000;">#</span><span style="color: #008000;"> 52.763017892837524</span></pre>
</div>
<span class="cnblogs_code_collapse">效率对比</span></div>
<p>greenlet只是提供了一种比generator更加便捷的切换方式，当切到一个任务执行时如果遇到io，那就原地阻塞，仍然是没有解决遇到IO自动切换来提升效率的问题。</p>
<p>单线程里的这20个任务的代码通常会既有计算操作又有阻塞操作，我们完全可以在执行任务1时遇到阻塞，就利用阻塞的时间去执行任务2。。。。如此，才能提高效率，这就用到了Gevent模块。</p>
<h1>Gevent模块</h1>
<p>安装：pip3 install gevent</p>
<p>Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是<strong>Greenlet</strong>, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('27648265-e5cb-4a3b-9105-c8790c098d43')"><img id="code_img_closed_27648265-e5cb-4a3b-9105-c8790c098d43" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_27648265-e5cb-4a3b-9105-c8790c098d43" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('27648265-e5cb-4a3b-9105-c8790c098d43',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_27648265-e5cb-4a3b-9105-c8790c098d43" class="cnblogs_code_hide">
<pre>g1=gevent.spawn(func,1,,2,3,x=4,y=5<span style="color: #000000;">)创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的

g2</span>=<span style="color: #000000;">gevent.spawn(func2)

g1.join() </span><span style="color: #008000;">#</span><span style="color: #008000;">等待g1结束</span>
<span style="color: #000000;">
g2.join() </span><span style="color: #008000;">#</span><span style="color: #008000;">等待g2结束</span>

<span style="color: #008000;">#</span><span style="color: #008000;">或者上述两步合作一步：gevent.joinall([g1,g2])</span>
<span style="color: #000000;">
g1.value</span><span style="color: #008000;">#</span><span style="color: #008000;">拿到func1的返回值</span></pre>
</div>
<span class="cnblogs_code_collapse">用法介绍</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('26ba0627-dbf2-4078-940e-5877fe092d8e')"><img id="code_img_closed_26ba0627-dbf2-4078-940e-5877fe092d8e" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_26ba0627-dbf2-4078-940e-5877fe092d8e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('26ba0627-dbf2-4078-940e-5877fe092d8e',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_26ba0627-dbf2-4078-940e-5877fe092d8e" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> gevent
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> eat(name):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s eat 1</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)
    gevent.sleep(</span>2<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s eat 2</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> play(name):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s play 1</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)
    gevent.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%s play 2</span><span style="color: #800000;">'</span> %<span style="color: #000000;">name)


g1</span>=gevent.spawn(eat,<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span><span style="color: #000000;">)
g2</span>=gevent.spawn(play,name=<span style="color: #800000;">'</span><span style="color: #800000;">egon</span><span style="color: #800000;">'</span><span style="color: #000000;">)
g1.join()
g2.join()
</span><span style="color: #008000;">#</span><span style="color: #008000;">或者gevent.joinall([g1,g2])</span>
<span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">例：遇到io主动切换</span></div>
<p><strong>上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞,</strong><strong>而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了</strong></p>
<p><strong>from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前</strong></p>
<p><strong>或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头</strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f3fa9838-d6ef-4e46-8306-6240911ee447')"><img id="code_img_closed_f3fa9838-d6ef-4e46-8306-6240911ee447" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f3fa9838-d6ef-4e46-8306-6240911ee447" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f3fa9838-d6ef-4e46-8306-6240911ee447',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f3fa9838-d6ef-4e46-8306-6240911ee447" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> gevent <span style="color: #0000ff;">import</span><span style="color: #000000;"> monkey;monkey.patch_all()

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> gevent
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> eat():
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">eat food 1</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    time.sleep(</span>2<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">eat food 2</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> play():
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">play 1</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    time.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">play 2</span><span style="color: #800000;">'</span><span style="color: #000000;">)

g1</span>=<span style="color: #000000;">gevent.spawn(eat)
g2</span>=<span style="color: #000000;">gevent.spawn(play)
gevent.joinall([g1,g2])
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>我们可以用threading.current_thread().getName()来查看每个g1和g2，查看的结果为DummyThread-n，即假线程</p>
<p><img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180121171049693-1429015151.png" alt="" width="324" height="126" /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('cc6f8a64-21a2-46a7-8e8b-fd3c69513dcc')"><img id="code_img_closed_cc6f8a64-21a2-46a7-8e8b-fd3c69513dcc" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_cc6f8a64-21a2-46a7-8e8b-fd3c69513dcc" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('cc6f8a64-21a2-46a7-8e8b-fd3c69513dcc',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_cc6f8a64-21a2-46a7-8e8b-fd3c69513dcc" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> gevent <span style="color: #0000ff;">import</span><span style="color: #000000;"> monkey;monkey.patch_all()
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> threading
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> gevent
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> eat():
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(threading.current_thread().getName())
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">eat food 1</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    time.sleep(</span>2<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">eat food 2</span><span style="color: #800000;">'</span><span style="color: #000000;">)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> play():
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(threading.current_thread().getName())
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">play 1</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    time.sleep(</span>1<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">play 2</span><span style="color: #800000;">'</span><span style="color: #000000;">)

g1</span>=<span style="color: #000000;">gevent.spawn(eat)
g2</span>=<span style="color: #000000;">gevent.spawn(play)
gevent.joinall([g1,g2])
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">主</span><span style="color: #800000;">'</span>)</pre>
</div>
<span class="cnblogs_code_collapse">查看threading.current_thread().getName()</span></div>
<p>&nbsp;</p>
<h2>Gevent之同步与异步</h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">from</span> gevent <span style="color: #0000ff;">import</span><span style="color: #000000;"> spawn,joinall,monkey;monkey.patch_all()

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> task(pid):
    </span><span style="color: #800000;">"""</span><span style="color: #800000;">
    Some non-deterministic task
    </span><span style="color: #800000;">"""</span><span style="color: #000000;">
    time.sleep(</span>0.5<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">Task %s done</span><span style="color: #800000;">'</span> %<span style="color: #000000;"> pid)


</span><span style="color: #0000ff;">def</span> synchronous():  <span style="color: #008000;">#</span><span style="color: #008000;"> 同步</span>
    <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">):
        task(i)

</span><span style="color: #0000ff;">def</span> asynchronous(): <span style="color: #008000;">#</span><span style="color: #008000;"> 异步</span>
    g_l=[spawn(task,i) <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(10<span style="color: #000000;">)]
    joinall(g_l)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">DONE</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">Synchronous:</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    synchronous()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">Asynchronous:</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    asynchronous()
</span><span style="color: #008000;">#</span><span style="color: #008000;">  上面程序的重要部分是将task函数封装到Greenlet内部线程的gevent.spawn。</span><span style="color: #008000;">
#</span><span style="color: #008000;">  初始化的greenlet列表存放在数组threads中，此数组被传给gevent.joinall 函数，</span><span style="color: #008000;">
#</span><span style="color: #008000;">  后者阻塞当前流程，并执行所有给定的greenlet任务。执行流程只会在 所有greenlet执行完后才会继续向下走。</span></pre>
</div>
<p>&nbsp;</p>
<h2>Gevent之应用举例一</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('753b20bb-1458-4865-982c-4534209f6ae4')"><img id="code_img_closed_753b20bb-1458-4865-982c-4534209f6ae4" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_753b20bb-1458-4865-982c-4534209f6ae4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('753b20bb-1458-4865-982c-4534209f6ae4',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_753b20bb-1458-4865-982c-4534209f6ae4" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> gevent <span style="color: #0000ff;">import</span><span style="color: #000000;"> monkey;monkey.patch_all()
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> gevent
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> requests
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> time

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get_page(url):
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">GET: %s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">url)
    response</span>=<span style="color: #000000;">requests.get(url)
    </span><span style="color: #0000ff;">if</span> response.status_code == 200<span style="color: #000000;">:
        </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">%d bytes received from %s</span><span style="color: #800000;">'</span> %<span style="color: #000000;">(len(response.text),url))


start_time</span>=<span style="color: #000000;">time.time()
gevent.joinall([
    gevent.spawn(get_page,</span><span style="color: #800000;">'</span><span style="color: #800000;">https://www.python.org/</span><span style="color: #800000;">'</span><span style="color: #000000;">),
    gevent.spawn(get_page,</span><span style="color: #800000;">'</span><span style="color: #800000;">https://www.yahoo.com/</span><span style="color: #800000;">'</span><span style="color: #000000;">),
    gevent.spawn(get_page,</span><span style="color: #800000;">'</span><span style="color: #800000;">https://github.com/</span><span style="color: #800000;">'</span><span style="color: #000000;">),
])
stop_time</span>=<span style="color: #000000;">time.time()
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">run time is %s</span><span style="color: #800000;">'</span> %(stop_time-start_time))</pre>
</div>
<span class="cnblogs_code_collapse">协程应用：爬虫</span></div>
<h2>Gevent之应用举例二</h2>
<p>通过gevent实现单线程下的socket并发</p>
<p><strong>注意 ：</strong>from gevent import monkey;monkey.patch_all()一定要放到导入socket模块之前，否则gevent无法识别socket的阻塞</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d9cac4d4-de11-4203-83ba-78795a69c87b')"><img id="code_img_closed_d9cac4d4-de11-4203-83ba-78795a69c87b" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d9cac4d4-de11-4203-83ba-78795a69c87b" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d9cac4d4-de11-4203-83ba-78795a69c87b',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d9cac4d4-de11-4203-83ba-78795a69c87b" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> gevent <span style="color: #0000ff;">import</span><span style="color: #000000;"> monkey;monkey.patch_all()
</span><span style="color: #0000ff;">from</span> socket <span style="color: #0000ff;">import</span> *
<span style="color: #0000ff;">import</span><span style="color: #000000;"> gevent

</span><span style="color: #008000;">#</span><span style="color: #008000;">如果不想用money.patch_all()打补丁,可以用gevent自带的socket</span><span style="color: #008000;">
#</span><span style="color: #008000;"> from gevent import socket</span><span style="color: #008000;">
#</span><span style="color: #008000;"> s=socket.socket()</span>

<span style="color: #0000ff;">def</span><span style="color: #000000;"> server(server_ip,port):
    s</span>=<span style="color: #000000;">socket(AF_INET,SOCK_STREAM)
    s.setsockopt(SOL_SOCKET,SO_REUSEADDR,</span>1<span style="color: #000000;">)
    s.bind((server_ip,port))
    s.listen(</span>5<span style="color: #000000;">)
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        conn,addr</span>=<span style="color: #000000;">s.accept()
        gevent.spawn(talk,conn,addr)

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> talk(conn,addr):
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;">:
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
            res</span>=conn.recv(1024<span style="color: #000000;">)
            </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">client %s:%s msg: %s</span><span style="color: #800000;">'</span> %(addr[0],addr[1<span style="color: #000000;">],res))
            conn.send(res.upper())
    </span><span style="color: #0000ff;">except</span><span style="color: #000000;"> Exception as e:
        </span><span style="color: #0000ff;">print</span><span style="color: #000000;">(e)
    </span><span style="color: #0000ff;">finally</span><span style="color: #000000;">:
        conn.close()

</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    server(</span><span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>,8080)</pre>
</div>
<span class="cnblogs_code_collapse">server</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('07586b30-60fe-428e-9c62-9c37fb0ed10d')"><img id="code_img_closed_07586b30-60fe-428e-9c62-9c37fb0ed10d" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_07586b30-60fe-428e-9c62-9c37fb0ed10d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('07586b30-60fe-428e-9c62-9c37fb0ed10d',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_07586b30-60fe-428e-9c62-9c37fb0ed10d" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> socket <span style="color: #0000ff;">import</span> *<span style="color: #000000;">

client</span>=<span style="color: #000000;">socket(AF_INET,SOCK_STREAM)
client.connect((</span><span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>,8080<span style="color: #000000;">))


</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
    msg</span>=input(<span style="color: #800000;">'</span><span style="color: #800000;">&gt;&gt;: </span><span style="color: #800000;">'</span><span style="color: #000000;">).strip()
    </span><span style="color: #0000ff;">if</span> <span style="color: #0000ff;">not</span> msg:<span style="color: #0000ff;">continue</span><span style="color: #000000;">

    client.send(msg.encode(</span><span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span><span style="color: #000000;">))
    msg</span>=client.recv(1024<span style="color: #000000;">)
    </span><span style="color: #0000ff;">print</span>(msg.decode(<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span>))</pre>
</div>
<span class="cnblogs_code_collapse">client</span></div>
<div class="cnblogs_code" onclick="cnblogs_code_show('2b64328f-c48f-436d-b921-06740e7e92f6')"><img id="code_img_closed_2b64328f-c48f-436d-b921-06740e7e92f6" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2b64328f-c48f-436d-b921-06740e7e92f6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2b64328f-c48f-436d-b921-06740e7e92f6',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2b64328f-c48f-436d-b921-06740e7e92f6" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">from</span> threading <span style="color: #0000ff;">import</span><span style="color: #000000;"> Thread
</span><span style="color: #0000ff;">from</span> socket <span style="color: #0000ff;">import</span> *
<span style="color: #0000ff;">import</span><span style="color: #000000;"> threading

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> client(server_ip,port):
    c</span>=socket(AF_INET,SOCK_STREAM) <span style="color: #008000;">#</span><span style="color: #008000;">套接字对象一定要加到函数内，即局部名称空间内，放在函数外则被所有线程共享，则大家公用一个套接字对象，那么客户端端口永远一样了</span>
<span style="color: #000000;">    c.connect((server_ip,port))

    count</span>=<span style="color: #000000;">0
    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> True:
        c.send((</span><span style="color: #800000;">'</span><span style="color: #800000;">%s say hello %s</span><span style="color: #800000;">'</span> %(threading.current_thread().getName(),count)).encode(<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span><span style="color: #000000;">))
        msg</span>=c.recv(1024<span style="color: #000000;">)
        </span><span style="color: #0000ff;">print</span>(msg.decode(<span style="color: #800000;">'</span><span style="color: #800000;">utf-8</span><span style="color: #800000;">'</span><span style="color: #000000;">))
        count</span>+=1
<span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(500<span style="color: #000000;">):
        t</span>=Thread(target=client,args=(<span style="color: #800000;">'</span><span style="color: #800000;">127.0.0.1</span><span style="color: #800000;">'</span>,8080<span style="color: #000000;">))
        t.start()</span></pre>
</div>
<span class="cnblogs_code_collapse">多线程并发多个客户端</span></div>
<p>&nbsp;</p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2018-01-21 17:22</span> <a href='https://www.cnblogs.com/Eva-J/'>Eva_J</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>) &nbsp;<a href="https://i.cnblogs.com/EditArticles.aspx?postid=8324673" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8324673);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=250832,cb_entryId=8324673,cb_blogApp=currentBlogApp,cb_blogUserGuid='4997edaa-857b-e511-9fc1-ac853d9f53cc',cb_entryCreatedDate='2018/1/21 17:22:00';loadViewCount(cb_entryId);var cb_postType=2;var isMarkdown=false;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>
<script>
  googletag.cmd.push(function() {
        googletag.defineSlot('/1090369/C1', [300, 250], 'div-gpt-ad-1546353474406-0').addService(googletag.pubads());
        googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
  });
</script>
<div id='cnblogs_c1' class='c_ad_block'>
    <div id='div-gpt-ad-1546353474406-0' style='height:250px; width:300px;'></div>
</div>
<div id='under_post_news'></div>
<div id='cnblogs_c2' class='c_ad_block'>
    <div id='div-gpt-ad-1539008685004-0' style='height:60px; width:468px;'></div>
</div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
 if(enablePostBottom()) {
    codeHighlight();
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverT2();
    deliverC1();
    deliverC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);  
}
</script>
</div>

    
	</div><!--end: topicList 文章列表容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="calendar"><div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script></div>
			
			<DIV id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</DIV>
			
		</div><!--end: sideBarMain -->
		<div class="clear"></div>
		<div id="footer">
			
<!--done-->
Copyright &copy;2019 Eva_J
		</div><!--end: footer -->
	</div><!--end: sideBar 侧边栏容器 -->
</div><!--end: home 自定义的最大容器 -->
</center>

</body>
</html>
